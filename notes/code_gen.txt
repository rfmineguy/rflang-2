Code gen for now will be limited to 32 bit code for now.

Functions:
  Arguments:
    - pushed onto the stack in order they appear 
    - to read the arguments we must access above the base pointer, and the first argument will be the furthest from the base pointer
    - Example:
        fn add(a: int, b: int) {
          sum: int = a + b;
          return sum;
        }
        
        'a' will be located at [rbp + 8] on 64bit, and [ebp + 4] on 32bit
        'b' will be located at [rbp + 16] on 64bit, and [ebp + 8] on 32bit
  
  Local variabless:
    - local variables will reside within the stack frame of the current function (a sort of scope)
    - enough stack space should be 'allocated' in order to accomodate the local variables
      - it will be required to analyse the parse tree to determine this metric
  
  Scopes:
    - not 100% sure how scopes should be implemented
      - should ALL scopes get their own stack frame? (for loops, while loops, if)
  
  Return:
    - if the function should return a value (syntax TBD), it should reside in rax. Otherwise, rax has no guarunteed value.
  
  Stack Frame:
    - all functions should create a stack frame for themselves
